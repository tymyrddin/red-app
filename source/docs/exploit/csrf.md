# Cross-Site Request Forgery (CSRF)

Cross-site scripting (XSS) exploits the trust a user has in a particular site, CSRF exploits the trust a site has in a 
user's browser.

* Requests are not validated server-side
* Server does not check whether request was generated by user
* Requests can be forged and sent to users (to make the server data leakage, change a session state, or manipulate a user's account)

CSRF will be possible if the session relies only on cookies or on HTTP Basic Authentication header, and there are no 
unpredictable parameters on the request.

## Attack tree

```text
1 Target user is logged in
2 Relevant action (POST request to change password or email, etc) (AND)
    2.1 Find page and vulnerable code
    2.2 Copy code
    2.3 Change parameters
3 Forged code on hacking website (a form with POST method and hidden input field containing the new password)
4 Deliver 
    4.1 Autosubmit
    4.2 Social engineering
```

## Example

### CSRF with GET request

To change password, the original code:

```text
<form action="#" method="GET">    New password:<br>
    <input type="password" autocomplete="off" name="password_new"><br>
    Confirm new password: <br>
    <input type="password" autocomplete="off" name="password_conf">
    <br>
    <input type="submit" value="Change" name="Change">
    </form>
```

The forged code (completely hidden):

```text
<form action="http://192.168.122.131/dvwa/vulnerabilities/csrf/" method="GET">
    <input type="hidden" value="666666" autocomplete="off" name="password_new">
    <input type="hidden" value="666666" autocomplete="off" name="password_conf">
    <input type="hidden" value="Change" name="Change">
    </form>
```

### CSRF with POST

Webgoat button to click and get the flag:

```text
<form accept-charset="UNKNOWN" id="basic-csrf-get" method="POST" name="form1" target="_blank" successcallback="" action="http://127.0.0.1:8080/WebGoat/csrf/basic-get-flag">
    <input name="csrf" type="hidden" value="false">
    <input type="submit" name="submit">
```

## CSRF Attack vectors

* Predictable tokens: Verify if tokens generated by the application aren’t easily guessable or possible to be reversed (for example MD5 of iterated integers).
* Lack of Anti-CSRF Token verification
  * Verify if the Anti-CSRF token value is verified in case of both POST and GET requests.
  * Verify if the values of Anti-CSRF token like NULL, None, 0, [] could bypass verification.
  * Verify if the token is required (verification depends on token being present).
* Token used only as a Cookie: Cookie will be attached to the request made from another domain (if there is no SameSite flag). If this value isn’t replicated as a header or one of request parameters, it isn’t valid defense.
* Token not tied to the user session: Verify if it’s possible to use valid token from another session.
* XSS: Having XSS, it is possible to extract CSRF token and use it.
* Brute force: Always check token entropy with at least 1000-10000 probes. If there is some pattern of creating tokens or if they repeat themselves, it is possible to try brute force it.
* Vulnerable subdomain: Having subdomain which is vulnerable to XSS, subdomain takeover or cookie injection, the attacker is able to bypass:
  * CSRF-token protection
  * Double-submit cookie protection
  * Content-type based protection
* Cookie injection: In case of CRLF-injection of browser bugs, it is possible to bypass double-submit cookie protection through cookie injection.

## Cheatsheets

* [Portswigger: CSRF](https://portswigger.net/web-security/csrf)