# Cross-Site Request Forgery 

## Look for state-changing actions

Log in to the target site and browse through it in search of any activity that alters data. Go through all the app’s functionalities, clicking all the links. Intercept the generated requests with a proxy like Burp or Zap, and write down their URL endpoints. Record these `endpoints` one by one, and include whether it is a `POST` or a `GET`, and the `request parameters`.

## Look for a lack of CSRF protections

Most security protection implemented to avoid attacks are based on csrf-tokens. The most frequently used development frameworks, such as Java Struts, .NET, Ruby on Rails, and PHP, include these tokens by default. And there are other methods, which can be bypassed:

### CSRF-unsafe protections

* Secret cookies: Some developers include a cookie with a value to validate that the request received by the application comes from a valid place. But the main problem with the cookies is that they are stored in the client side, so it is possible to get them just by submitting a request using the web browser. These cookies work more as a session identifier than an anti-CSRF token; they are just like adding two session IDs.
* Request restrictions: Some developers limit the type of request received by the application to just accept POST requests, but, it is entirely possible to exploit a CSRF using POST requests.
* Complex flow: Some developers create complex application flows to avoid these kinds of attacks, like confirming critical actions. We just need to understand how the process works using an HTTP proxy, not automating the attack in the same way as the others.
* URL rewriting: To confuse the attackers, some developers rewrite the URLs used in the request, or use named magic URLs, which are URLs rewritten to be shorter and look better when you are managing long paths. And, as all the information is sent into the request, the attacker can just copy and use the same information to perform the attack.
* Using HTTPS instead of HTTP: To protect the request, sometimes, HTTP is used. Never mind, because the Proxy intercepts all the information.

### CSRF - more safe protection

* Form keys: A key included in each request to a URL; so, if a malicious user sent a repeated key, the application would avoid the attack.
* Hashes: It is possible to add hashes for sessions, methods, keys, and so on.
* View state: .NET has implemented a control and named view state, that tracks the user session, but it includes a specific control to avoid manipulation, and also a hash to protect it.
* Referer: The HTTP requests have a header known as referer. You can use it to prevent requests from unexpected sites. However, do not trust a lot on it. Anything can be modified from the client side.
* Tokens: The most extended security control to avoid CSRF is the use of tokens. These are usually hashed identifiers that can also include secret data, such as the referer information, to protect the requests.
* Referer headers can be manipulated by attackers and aren’t a foolproof mitigation solution. Developers should implement a combination of CSRF tokens and `SameSite` session cookies for the best protection.

And if the protection used is incomplete or faulty, you might still be able to achieve a CSRF attack with a few modifications to your payload.

## Detecting and exploiting CSRF

Use the Site map tab in Burp or Zap, to detect when a resource is called to other domains.

Create CSRF templates to automate the exploitation to confirm the vulnerabilities. 

    <form method='POST' action='http://targetsite.com/form.php'>
    <input type='hidden' name='criticaltoggle' value='true'
    <input type='submit' value='submit'>
    </form>

## Bypassing CSRF protection

### Exploit Clickjacking

If the endpoint uses CSRF tokens but the page itself is vulnerable to clickjacking, you can exploit clickjacking to achieve the same results as a CSRF, because clickjacking uses an iframe to frame the page in a malicious site while having the state-changing request originate from the legitimate site.

    <html>
    <head>
    <title>Clickjack test page</title>
    </head>
    <body>
    <p>This page is vulnerable to clickjacking if the iframe is not blank!</p>
    <iframe src="PAGE_URL" width="500" height="500"></iframe>
    </body>
    </html>

## Using XSS as helper

In some cases an application an anti-CSRF protection and is well-implemented, but it is possible to defeat the anti-CSRF protection by using an XSS technique. When the application receives the XSS attacks, it will have the token or hash included as protection. The purpose is not injecting the code, but getting the token to use it in other requests. For example:

* A stored XSS could read all the tokens in an application, because a stored XSS is launched by the application, and any response launched by it will have the token – even an XSS launched.
* In applications that have more than one step to perform an action, it is possible that the anti-CSRF protection had been just included in the critical step. If you can perform an XSS attack in one of the unprotected sections, it is possible that you will get the token or hash used for the critical step. It is the first step, by logic, and is used to transfer the user to the second step, so the XSS attack is just following the application's natural flow.
* When the anti-CSRF protection is related with a username not in their session, the only way is to get the credentials in order to exploit the CSRF, not just the token is needed. To do that, one of the last opportunities is an XSS attack to steal the login information, and at the same time retrieve the token by the logic application itself.

## Avoiding problems with authentication

Most CSRF attacks depend on the user session, which needs to be established before performing the actions using the privileged access defined in the user's profile. And some developers include confirmations to perform some actions.

One of the most common examples of this is the change password functionality. Maybe by exploiting a CSRF, a user can upload a new password, but the application could ask for the current password in order to accept the change. This confirmation is really a new authentication.

Add to the form being used to exploit the vulnerability and the feature to ask for a new password, this functionality:

    {# CSRF #}
    {% set csrf = false %}
    {% set target_url = 'https://github.com/securestate/king-phisher' %}
    {% do
    request.parameters.update({
    'username': request.parameters['username'],
    'password': request.parameters['password']
    })
    %}

For bug bounty hunting and pentesting, not a problem, because you just need to confirm that it is possible. For malicious users and red teamers somewhat of a problem, because the forms must look real to victims, to avoid detection.

## Resources

* [Portswigger: CSRF](https://portswigger.net/web-security/csrf)
* [OWASP: Testing for Cross Site Request Forgery](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery)
